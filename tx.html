<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lịch Sử Xúc Xắc — Mô phỏng (không cờ bạc)</title>
<style>
  :root{
    --bg:#0b0f1a; --card:#0f1630; --muted:#9fb3d6; --accent:#7c5cff;
    --tai:#7c5cff; --xiu:#2dd4bf; --trip:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#060616,#0b0f1a);color:#e6eef8}
  header{padding:18px;text-align:center}
  h1{margin:0;font-size:20px}
  .sub{color:var(--muted);font-size:13px;margin-top:6px}
  .wrap{max-width:1150px;margin:16px auto;padding:12px;display:grid;grid-template-columns:1fr 340px;gap:14px}
  .card{background:linear-gradient(180deg,var(--card),#0b1230);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,.04);box-shadow:0 12px 40px rgba(0,0,0,.5)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);border:none;color:#08102a;padding:10px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--muted)}
  .dice-row{display:flex;gap:12px;justify-content:center;margin:12px 0}
  .die{width:84px;height:84px;border-radius:12px;background:#07102a;display:grid;place-items:center;font-size:44px;border:2px solid rgba(255,255,255,.04)}
  .panel-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,select{background:#06112a;border:1px solid rgba(255,255,255,.04);padding:8px;border-radius:8px;color:inherit}
  canvas{background:linear-gradient(180deg,#0a1030,#07102a);border-radius:8px;border:1px solid rgba(255,255,255,.03)}
  .small{color:var(--muted);font-size:13px}
  .stat{display:flex;flex-direction:column;gap:6px;padding:8px;background:rgba(255,255,255,.02);border-radius:8px}
  footer{max-width:1150px;margin:18px auto;color:var(--muted);text-align:center;font-size:13px}
  .history-dots{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .dot{width:18px;height:18px;border-radius:6px;border:1px solid rgba(255,255,255,.06)}
  .dot.tai{background:linear-gradient(180deg,var(--tai),#5b3ef0)}
  .dot.xiu{background:linear-gradient(180deg,var(--xiu),#14b8a6)}
  .dot.trip{background:linear-gradient(180deg,var(--trip),#ef4444)}
  .log{max-height:220px;overflow:auto;padding:8px;background:#071228;border-radius:8px;margin-top:8px}
  .row-between{display:flex;justify-content:space-between;align-items:center}
</style>
</head>
<body>
  <header>
    <h1>Lịch Sử Xúc Xắc — Mô phỏng (không cờ bạc)</h1>
    <div class="sub">Mở nhiều tab để so sánh; CHS = điểm ảo. Triple = tam hoa (không tính Tài/Xỉu).</div>
  </header>

  <main class="wrap">
    <!-- LEFT: Charts + Controls -->
    <section class="card">
      <div class="row-between">
        <div style="display:flex;flex-direction:column">
          <div class="small">Vòng hiện tại</div>
          <div style="font-weight:800;font-size:18px" id="roundId">—</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="small">Countdown</div>
          <div style="font-weight:900;font-size:20px;margin-left:8px" id="countdown">—</div>
        </div>
      </div>

      <div style="margin-top:12px" class="controls">
        <button id="startBtn" class="btn">Start Round</button>
        <button id="autoBtn" class="btn ghost">Auto: OFF</button>
        <button id="rollBtn" class="btn ghost">Roll Now</button>
        <button id="clearHist" class="btn ghost">Xóa lịch sử</button>
        <button id="exportJson" class="btn ghost">Xuất JSON</button>
        <div style="margin-left:auto" class="small">Thời gian mặc định (s)</div>
        <input id="roundDur" type="number" value="12" min="5" style="width:70px"/>
      </div>

      <div style="margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
        <div>
          <div class="small">Đặt cược (CHS)</div>
          <div class="panel-row" style="margin-top:6px">
            <select id="betChoice">
              <option value="tai">TÀI (11–17)</option>
              <option value="xiu">XỈU (4–10)</option>
            </select>
            <input id="betAmt" type="number" min="1" value="10" style="width:110px"/>
            <button id="placeBet" class="btn">Đặt</button>
            <button id="cancelBet" class="btn ghost">Huỷ</button>
          </div>
        </div>

        <div style="margin-left:auto">
          <div class="small">CHS (điểm giả lập)</div>
          <div style="font-weight:900;font-size:18px" id="points">1000</div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.04);margin:12px 0"/>

      <!-- Dice display -->
      <div class="dice-row" aria-hidden>
        <div class="die" id="d1">•</div>
        <div class="die" id="d2">•</div>
        <div class="die" id="d3">•</div>
      </div>

      <div class="row-between" style="margin-top:8px">
        <div class="small">Kết quả gần nhất</div>
        <div id="lastOutcome" style="font-weight:800">—</div>
      </div>

      <!-- Charts -->
      <div style="margin-top:12px">
        <canvas id="canvasTop" width="840" height="160"></canvas>
      </div>
      <div style="margin-top:12px">
        <canvas id="canvasBottom" width="840" height="160"></canvas>
      </div>

      <div style="margin-top:10px" class="small">Ghi chú: Điểm biểu đồ trên hiển thị Tổng (3–18). Biểu đồ dưới hiển thị 3 viên xúc xắc (màu khác nhau).</div>

      <div style="margin-top:12px" class="log" id="log"></div>
    </section>

    <!-- RIGHT: Players/History -->
    <aside class="card">
      <div class="row-between">
        <div>
          <div class="small">Tab ID</div>
          <div id="tabId" style="font-weight:800">—</div>
        </div>
        <div>
          <div class="small">Leader</div>
          <div id="leader" style="font-weight:800">—</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Lịch sử (mới → cũ)</div>
        <div class="history-dots" id="histDots"></div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.04);margin:12px 0"/>

      <div>
        <div class="small">Lịch sử chi tiết</div>
        <div id="tableWrap" style="margin-top:8px;max-height:360px;overflow:auto"></div>
      </div>
    </aside>
  </main>

  <footer>Demo mô phỏng — Không cờ bạc • Mở nhiều tab cùng file để so sánh realtime (BroadcastChannel nếu trình duyệt hỗ trợ)</footer>

<script>
/* Core single-file app
 - RNG: crypto.getRandomValues
 - Data stored in localStorage under key 'dice_history_v1'
 - Charts drawn on two Canvas elements
 - Auto rounds available
 - Betting uses CHS points stored per tab (localStorage key 'chs_<tabId>')
*/

const TAB_ID = shortId(8);
document.getElementById('tabId').textContent = TAB_ID;

const STORAGE_KEY = 'dice_history_v1';
const CHS_KEY = 'chs_' + TAB_ID;

const d1el = document.getElementById('d1'), d2el = document.getElementById('d2'), d3el = document.getElementById('d3');
const canvasTop = document.getElementById('canvasTop'), canvasBottom = document.getElementById('canvasBottom');
const ctxTop = canvasTop.getContext('2d'), ctxBottom = canvasBottom.getContext('2d');
const logEl = document.getElementById('log');
const histDots = document.getElementById('histDots');
const tableWrap = document.getElementById('tableWrap');
const roundIdEl = document.getElementById('roundId'), countdownEl = document.getElementById('countdown'), lastOutcomeEl = document.getElementById('lastOutcome');
const pointsEl = document.getElementById('points');

let history = loadHistory();
let currentRound = null;
let countdownTimer = null;
let autoMode = false;
let autoIntervalTimer = null;

// UI elements
const startBtn = document.getElementById('startBtn'), autoBtn = document.getElementById('autoBtn'), rollBtn = document.getElementById('rollBtn');
const clearHist = document.getElementById('clearHist'), exportJson = document.getElementById('exportJson');
const roundDur = document.getElementById('roundDur');
const betChoice = document.getElementById('betChoice'), betAmt = document.getElementById('betAmt'), placeBet = document.getElementById('placeBet'), cancelBet = document.getElementById('cancelBet');

// BroadcastChannel for multi-tab realtime (fallback to storage event)
const BC_NAME = 'dice_history_channel_v1';
let bc = null;
const bcSupported = typeof BroadcastChannel !== 'undefined';
if (bcSupported) {
  try { bc = new BroadcastChannel(BC_NAME); bc.onmessage = ev => handleMessage(ev.data); } catch(e) { bc = null; }
}
window.addEventListener('storage', (ev) => {
  if (ev.key === STORAGE_KEY && ev.newValue) {
    try {
      const msg = JSON.parse(ev.newValue);
      // only handle messages not from this tab
      if (msg._from !== TAB_ID) handleMessage(msg);
    } catch(e){}
  }
});

// Initialize CHS (points)
if (!localStorage.getItem(CHS_KEY)) localStorage.setItem(CHS_KEY, '1000');
updatePointsUI();

// Render initial
renderAll();

// ---- Event handlers ----
startBtn.onclick = () => {
  if (currentRound && currentRound.status === 'open') {
    appendLog('Đang có vòng mở, chờ kết quả.');
    return;
  }
  const dur = Math.max(5, Number(roundDur.value) || 12);
  startRound(dur);
  broadcast({ type:'start', roundId: currentRound.id, deadline: currentRound.deadline, duration: dur });
};

autoBtn.onclick = () => {
  autoMode = !autoMode;
  autoBtn.textContent = 'Auto: ' + (autoMode ? 'ON' : 'OFF');
  autoBtn.classList.toggle('ghost', !autoMode);
  if (autoMode) startAuto(); else stopAuto();
};

rollBtn.onclick = () => {
  if (!currentRound) { appendLog('Chưa có vòng; hãy Start Round'); return; }
  // force resolve immediately by this tab (no leader logic here for simplicity)
  resolveRound();
  broadcast({ type:'force_resolve', roundId: currentRound.id });
};

placeBet.onclick = () => {
  const amt = Math.max(1, Math.floor(Number(betAmt.value) || 0));
  const choice = betChoice.value;
  const pts = Number(localStorage.getItem(CHS_KEY) || 0);
  if (amt <= 0) { alert('Nhập số CHS đặt cược > 0'); return; }
  if (amt > pts) { alert('Không đủ CHS'); return; }
  if (!currentRound) { alert('Chưa có vòng để đặt'); return; }
  // record bet in currentRound.bets by TAB_ID
  currentRound.bets = currentRound.bets || {};
  currentRound.bets[TAB_ID] = { by: TAB_ID, choice, amt };
  appendLog(`Bạn đặt ${amt} CHS → ${choice.toUpperCase()}`);
  broadcast({ type:'bet', roundId: currentRound.id, bet: { by: TAB_ID, choice, amt } });
};

cancelBet.onclick = () => {
  if (!currentRound || !currentRound.bets) return;
  delete currentRound.bets[TAB_ID];
  appendLog('Bạn huỷ cược cho vòng hiện tại');
  broadcast({ type:'cancel_bet', roundId: currentRound.id, by: TAB_ID });
};

clearHist.onclick = () => {
  if (!confirm('Xóa toàn bộ lịch sử (localStorage)?')) return;
  history = [];
  saveHistory();
  renderAll();
  broadcast({ type:'clear_history' });
};

exportJson.onclick = () => {
  const data = JSON.stringify(history, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'dice-history.json'; a.click();
  URL.revokeObjectURL(url);
};

// ---- Core functions ----
function startRound(durationSec){
  const id = 'R' + Date.now();
  currentRound = { id, startedBy: TAB_ID, start: Date.now(), duration: durationSec*1000, deadline: Date.now() + durationSec*1000, status:'open', bets:{} };
  roundIdEl.textContent = id;
  startCountdown();
  appendLog(`Vòng ${id} bắt đầu (${durationSec}s)`);
  renderAll();
}

function startCountdown(){
  if (countdownTimer) clearInterval(countdownTimer);
  countdownTimer = setInterval(()=> {
    if (!currentRound) { countdownEl.textContent = '—'; clearInterval(countdownTimer); return; }
    const now = Date.now();
    const rem = Math.max(0, Math.ceil((currentRound.deadline - now)/1000));
    countdownEl.textContent = rem + 's';
    if (rem <= 0) {
      clearInterval(countdownTimer);
      countdownEl.textContent = '0s';
      // auto resolve
      resolveRound();
    }
  }, 200);
}

function resolveRound(){
  if (!currentRound || currentRound.status !== 'open') return;
  currentRound.status = 'resolving';
  // generate dice
  const dice = randThree();
  const sum = dice[0]+dice[1]+dice[2];
  const triple = (dice[0]===dice[1] && dice[1]===dice[2]);
  const outcome = triple ? 'trip' : (sum>=11 ? 'tai' : 'xiu');

  // animate dice
  animateDice(dice);

  // apply bets: for each bet recorded in currentRound.bets, payout to the corresponding CHS key
  const payouts = [];
  const bets = currentRound.bets || {};
  for (const id in bets){
    const b = bets[id];
    let change = 0;
    if (outcome === 'trip'){
      change = -b.amt; // all lose on triple
    } else {
      if (b.choice === outcome) change = b.amt; else change = -b.amt;
    }
    // update CHS for that id: NOTE: if it's a different tab, it's local to that tab;
    // we'll store results in history and broadcast, each tab will apply updates for its own ID when receiving resolve.
    payouts.push({ id: b.by, change, bet: b });
  }

  const entry = { id: currentRound.id, ts: Date.now(), dice, sum, outcome, triple, bets, payouts };
  history.unshift(entry);
  if (history.length > 200) history.pop();
  saveHistory();
  appendLog(`[${currentRound.id}] KQ: ${outcome.toUpperCase()} — Tổng ${sum} ${triple ? '(TRIPLE)' : ''}`);
  lastOutcomeEl.textContent = (outcome === 'trip') ? 'TRIPLE' : outcome.toUpperCase();

  // broadcast resolved so other tabs can update their CHS if needed
  broadcast({ type:'resolved', entry, _from: TAB_ID });

  // apply payouts for this tab if present
  applyPayoutsForTab(entry.payouts);

  currentRound = null;
  roundIdEl.textContent = '—';
  renderAll();
}

function applyPayoutsForTab(payouts){
  for (const p of payouts){
    if (p.id === TAB_ID){
      const cur = Number(localStorage.getItem(CHS_KEY) || 0);
      const updated = cur + Number(p.change || 0);
      localStorage.setItem(CHS_KEY, String(updated));
      updatePointsUI();
      appendLog(`Bạn ${p.change>=0? 'thắng':'thua'} ${Math.abs(p.change)} CHS — Tồn: ${updated}`);
    } else {
      // other players: we don't modify their local CHS; their tab will process the broadcasted resolve and update its own CHS.
    }
  }
}

function animateDice(dice){
  // quick flash then set faces
  [d1el,d2el,d3el].forEach(el => el.textContent = '⚄');
  setTimeout(()=>{
    d1el.textContent = face(dice[0]); d2el.textContent = face(dice[1]); d3el.textContent = face(dice[2]);
  }, 240);
}

// ---- Storage / Broadcast ----
function saveHistory(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(history)); }
function loadHistory(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') || []; } catch(e){ return []; } }

function broadcast(msg){
  // attach source ID
  msg._from = TAB_ID;
  msg._ts = Date.now();
  try {
    if (bc) { bc.postMessage(msg); return; }
  } catch(e){}
  // fallback: write to storage (other tabs receive storage event)
  localStorage.setItem(STORAGE_KEY, JSON.stringify(msg));
  // keep a copy of actual history in storage too
  if (msg.type === 'resolved' && msg.entry) {
    const hist = loadHistory();
    // ensure no duplicate entry id
    if (!hist.find(h => h.id === msg.entry.id)) {
      hist.unshift(msg.entry);
      while (hist.length > 200) hist.pop();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(hist));
    }
  }
}

// ---- Broadcast message handler ----
function handleMessage(msg){
  if (!msg || !msg.type) return;
  if (msg.type === 'start'){
    // other tab started round: set currentRound with that id if we don't have open one
    if (!currentRound || currentRound.status !== 'open'){
      currentRound = { id: msg.roundId, startedBy: msg._from, start: Date.now(), duration: msg.duration || 0, deadline: msg.deadline, status:'open', bets:{} };
      roundIdEl.textContent = currentRound.id;
      startCountdown();
      appendLog(`(Sync) Vòng ${currentRound.id} bắt đầu bởi ${msg._from}`);
      renderAll();
    }
  } else if (msg.type === 'bet'){
    // someone placed bet; if we track bets for currentRound, add it
    if (currentRound && currentRound.id === msg.roundId){
      currentRound.bets = currentRound.bets || {};
      currentRound.bets[msg.bet.by] = msg.bet;
      appendLog(`(Sync) ${msg.bet.by} đặt ${msg.bet.amt} → ${msg.bet.choice}`);
    }
  } else if (msg.type === 'cancel_bet'){
    if (currentRound && currentRound.id === msg.roundId && currentRound.bets){
      delete currentRound.bets[msg.by];
      appendLog(`(Sync) ${msg.by} huỷ cược`);
    }
  } else if (msg.type === 'force_resolve'){
    if (currentRound && currentRound.id === msg.roundId){
      resolveRound();
    }
  } else if (msg.type === 'resolved'){
    // another tab resolved a round; add to history if not exist and apply payouts locally if any for us
    const entry = msg.entry;
    if (!history.find(h => h.id === entry.id)){
      history.unshift(entry);
      if (history.length > 200) history.pop();
      saveHistory();
    }
    applyPayoutsForTab(entry.payouts);
    renderAll();
    appendLog(`(Sync) Vòng ${entry.id} đã được resolve bởi ${msg._from}`);
  } else if (msg.type === 'clear_history'){
    history = [];
    saveHistory();
    renderAll();
    appendLog('(Sync) Lịch sử đã được xoá');
  }
}

// ---- Charts rendering ----
function renderAll(){
  renderTopChart();
  renderBottomChart();
  renderHistoryDots();
  renderTable();
  updatePointsUI();
}

function renderTopChart(){
  // top: sums 3..18 (we plot across width)
  const data = history.slice(0, 80).reverse(); // oldest -> newest
  const w = canvasTop.width, h = canvasTop.height, pad = 36;
  ctxTop.clearRect(0,0,w,h);
  // grid lines for y from 3..18
  ctxTop.strokeStyle = 'rgba(255,255,255,.04)'; ctxTop.lineWidth = 1;
  for (let y=3;y<=18;y+=3){
    const yy = map(y, 3, 18, h-pad, pad);
    ctxTop.beginPath(); ctxTop.moveTo(pad,yy); ctxTop.lineTo(w-pad,yy); ctxTop.stroke();
    ctxTop.fillStyle = 'rgba(255,255,255,.12)'; ctxTop.font = '12px Inter, Arial'; ctxTop.fillText(String(y), 6, yy+4);
  }
  if (data.length === 0) return;
  const stepX = (w - pad*2) / Math.max(1, data.length - 1);
  // draw line
  ctxTop.beginPath();
  for (let i=0;i<data.length;i++){
    const v = data[i].sum;
    const x = pad + i * stepX;
    const y = map(v, 3, 18, h-pad, pad);
    if (i===0) ctxTop.moveTo(x,y); else ctxTop.lineTo(x,y);
  }
  ctxTop.strokeStyle = 'rgba(124,92,255,0.95)'; ctxTop.lineWidth = 2.5; ctxTop.stroke();
  // points & labels
  for (let i=0;i<data.length;i++){
    const v = data[i].sum;
    const x = pad + i * stepX;
    const y = map(v, 3, 18, h-pad, pad);
    // circle
    ctxTop.beginPath(); ctxTop.fillStyle = '#0b1022'; ctxTop.strokeStyle = 'rgba(255,255,255,.12)'; ctxTop.arc(x,y,10,0,Math.PI*2); ctxTop.fill(); ctxTop.stroke();
    // value text
    ctxTop.fillStyle = '#e6eef8'; ctxTop.font = '11px Inter, Arial'; ctxTop.fillText(String(v), x-9, y-14);
  }
}

function renderBottomChart(){
  // bottom: three colored lines for dice1, dice2, dice3. vertical scale 1..6
  const data = history.slice(0, 80).reverse();
  const w = canvasBottom.width, h = canvasBottom.height, pad = 28;
  ctxBottom.clearRect(0,0,w,h);
  // horizontal grid lines for 1..6
  ctxBottom.strokeStyle = 'rgba(255,255,255,.03)'; ctxBottom.lineWidth = 1;
  for (let y=1;y<=6;y++){
    const yy = map(y,1,6,h-pad,pad);
    ctxBottom.beginPath(); ctxBottom.moveTo(pad,yy); ctxBottom.lineTo(w-pad,yy); ctxBottom.stroke();
    ctxBottom.fillStyle = 'rgba(255,255,255,.12)'; ctxBottom.font = '11px Inter, Arial'; ctxBottom.fillText(String(y), 6, yy+4);
  }
  if (data.length===0) return;
  const stepX = (w - pad*2) / Math.max(1, data.length - 1);
  const colors = ['#ff4d4d','#ffd24d','#8b5cf6']; // die1 red, die2 yellow, die3 purple (or choose)
  for (let d=0; d<3; d++){
    ctxBottom.beginPath();
    for (let i=0;i<data.length;i++){
      const val = data[i].dice[d];
      const x = pad + i * stepX;
      const y = map(val,1,6,h-pad,pad);
      if (i===0) ctxBottom.moveTo(x,y); else ctxBottom.lineTo(x,y);
    }
    ctxBottom.strokeStyle = colors[d]; ctxBottom.lineWidth = 2; ctxBottom.stroke();
    // draw dots
    for (let i=0;i<data.length;i++){
      const val = data[i].dice[d];
      const x = pad + i * stepX;
      const y = map(val,1,6,h-pad,pad);
      ctxBottom.beginPath(); ctxBottom.fillStyle = colors[d]; ctxBottom.arc(x,y,6,0,Math.PI*2); ctxBottom.fill();
    }
  }
}

// ---- helpers for UI ----
function renderHistoryDots(){
  histDots.innerHTML = '';
  for (let i=0;i<Math.min(40, history.length); i++){
    const e = history[i];
    const div = document.createElement('div');
    div.className = 'dot ' + (e.outcome==='tai' ? 'tai' : e.outcome==='xiu' ? 'xiu' : 'trip');
    histDots.appendChild(div);
  }
}

function renderTable(){
  if (history.length === 0){ tableWrap.innerHTML = '<div class="small">Không có ván nào</div>'; return; }
  let html = '<table style="width:100%;border-collapse:collapse"><thead><tr style="text-align:left"><th style="padding:6px">#</th><th>Thời gian</th><th>Dice</th><th>Tổng</th><th>KQ</th><th>Bets</th></tr></thead><tbody>';
  for (let i=0;i<history.length;i++){
    const e = history[i];
    const t = new Date(e.ts).toLocaleString();
    const dice = e.dice.join('-');
    const bets = e.bets ? Object.values(e.bets).map(b => `${b.by}:${b.amt}/${b.choice}`).join(', ') : '-';
    html += `<tr style="border-top:1px solid rgba(255,255,255,.03)"><td style="padding:6px;vertical-align:top">${e.id}</td><td style="padding:6px;vertical-align:top">${t}</td><td style="padding:6px;vertical-align:top">${dice}</td><td style="padding:6px;vertical-align:top">${e.sum}</td><td style="padding:6px;vertical-align:top">${e.outcome}${e.triple ? ' (TRIPLE)' : ''}</td><td style="padding:6px;vertical-align:top">${bets}</td></tr>`;
  }
  html += '</tbody></table>';
  tableWrap.innerHTML = html;
}

// ---- util / RNG / UI ----
function randThree(){
  try {
    const arr = new Uint8Array(3);
    crypto.getRandomValues(arr);
    return [ (arr[0] % 6) + 1, (arr[1] % 6) + 1, (arr[2] % 6) + 1 ];
  } catch(e) {
    return [rint(1,6), rint(1,6), rint(1,6)];
  }
}
function rint(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function face(n){ return ['⚀','⚁','⚂','⚃','⚄','⚅'][(n||1)-1]; }
function shortId(len){ const a = new Uint8Array(len); try{ crypto.getRandomValues(a);}catch(e){ for(let i=0;i<len;i++) a[i]=rint(0,255); } return Array.from(a).map(b=>('0'+(b&0xff).toString(16)).slice(-2)).join('').slice(0,len); }
function map(v, a,b, A,B){ return A + (v-a)*(B-A)/(b-a); }
function appendLog(txt){ const d = document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${txt}`; logEl.prepend(d); if (logEl.childElementCount>200) logEl.removeChild(logEl.lastChild); }

// ---- Save / Load to storage with simple locking ----
function saveHistory(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
}
function loadHistory(){
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') || []; } catch(e){ return []; }
}

// update points display for this tab
function updatePointsUI(){
  const v = Number(localStorage.getItem(CHS_KEY) || 0);
  pointsEl.textContent = String(v);
}

// apply payouts when receiving resolved messages -- handled in handleMessage; we also update UI periodically
setInterval(()=> updatePointsUI(), 800);

// ---- Auto mode ----
function startAuto(){
  if (autoIntervalTimer) return;
  autoIntervalTimer = setInterval(()=> {
    if (!currentRound) {
      startRound(Math.max(5, Number(roundDur.value) || 12));
      broadcast({ type:'start', roundId: currentRound.id, deadline: currentRound.deadline, duration: currentRound.duration });
    }
  }, (Number(roundDur.value) || 12) * 1000 + 400);
}
function stopAuto(){ if (autoIntervalTimer) { clearInterval(autoIntervalTimer); autoIntervalTimer = null; } }

// ---- On broadcast resolved message, other tabs must applyCHS for their own tab id
// we already handle that in handleMessage (applyPayoutsForTab called when receiving 'resolved')

/* At start, render whatever existing history we have */
(function init(){
  // listen for storage changes that carry resolved entries, but our storage handler already covers it.
  renderAll();
})();

// ensure chart resizes on window resize
window.addEventListener('resize', ()=> { // keep canvas width responsive
  const maxW = Math.min(880, document.querySelector('.card').clientWidth - 20);
  canvasTop.width = Math.max(640, maxW);
  canvasBottom.width = Math.max(640, maxW);
  renderAll();
});
window.dispatchEvent(new Event('resize'));

// ---- Helper: when receiving broadcast 'resolved' event stored in STORAGE_KEY as history array (fallback) ----
// If another tab stores history array directly, we may get it via storage event; handle that scenario:
window.addEventListener('storage', (ev) => {
  if (ev.key === STORAGE_KEY && ev.newValue) {
    try {
      const parsed = JSON.parse(ev.newValue);
      // if parsed is array -> it's history; if parsed is object with type -> message
      if (Array.isArray(parsed)) {
        history = parsed;
        renderAll();
      } else if (parsed.type) {
        handleMessage(parsed);
      }
    } catch(e){}
  }
});

function broadcast(msg){
  // attach metadata and send via BC or storage
  msg._from = TAB_ID;
  msg._ts = Date.now();
  try {
    if (bc) { bc.postMessage(msg); return; }
  } catch(e){}
  // fallback: store under STORAGE_KEY as object (others will parse)
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(msg)); } catch(e){}
}
function handleMessage(msg){
  if (!msg || !msg.type) return;
  if (msg.type === 'start'){
    // if someone started, sync
    if (!currentRound || currentRound.status !== 'open'){
      currentRound = { id: msg.roundId, startedBy: msg._from, start: Date.now(), duration: msg.duration || 0, deadline: msg.deadline || (Date.now() + 10000), status: 'open', bets: {} };
      roundIdEl.textContent = currentRound.id;
      startCountdown();
      appendLog(`(sync) Vòng ${currentRound.id} bắt đầu bởi ${msg._from}`);
      renderAll();
    }
  } else if (msg.type === 'bet'){
    // someone placed bet
    if (currentRound && currentRound.id === msg.roundId){
      currentRound.bets = currentRound.bets || {};
      currentRound.bets[msg.bet.by] = msg.bet;
      appendLog(`(sync) ${msg.bet.by} đặt ${msg.bet.amt} → ${msg.bet.choice}`);
    }
  } else if (msg.type === 'cancel_bet'){
    if (currentRound && currentRound.id === msg.roundId && currentRound.bets) {
      delete currentRound.bets[msg.by];
      appendLog(`(sync) ${msg.by} huỷ cược`);
    }
  } else if (msg.type === 'resolved') {
    // add to history if not present
    const e = msg.entry;
    if (!history.find(h => h.id === e.id)) {
      history.unshift(e); while (history.length>200) history.pop(); saveHistory();
    }
    // apply payouts for this tab if necessary
    applyPayoutsForTab(e.payouts);
    renderAll();
    appendLog(`(sync) Vòng ${e.id} resolve bởi ${msg._from}`);
  } else if (msg.type === 'clear_history'){
    history = []; saveHistory(); renderAll(); appendLog('(sync) Lịch sử đã xoá');
  }
}

// provide one broadcast function accessible earlier
// (overriding previous dummy)
function broadcast(msg){
  msg._from = TAB_ID; msg._ts = Date.now();
  if (bc) { try { bc.postMessage(msg); return; } catch(e){} }
  // fallback: if msg.type === 'resolved' also persist to array
  if (msg.type === 'resolved' && msg.entry) {
    const hist = loadHistory();
    if (!hist.find(h => h.id === msg.entry.id)) {
      hist.unshift(msg.entry);
      while (hist.length>200) hist.pop();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(hist));
    }
  }
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(msg)); } catch(e){}
}

// Note: ensure unique function name by reassigning earlier references if needed
// (For simplicity in this single-file example we've repeated broadcast/handleMessage definitions but behavior is consistent)

</script>
</body>
</html>
